# Report

Audit report for **2023-10-ens** generated by *Bot-Henry*.

> Note: There is a section for disputed findings below the usual findings sections.

## Summary

### Medium Issues

Total **1 instance** over **1 issue**:

|ID|Issue|Instances|
|:--:|:---|:--:|
| [[M&#x2011;01]](#m01-centralization-risk-for-privileged-functions) | Centralization risk for privileged functions | 1 |

### Low Issues

Total **22 instances** over **10 issues**:

|ID|Issue|Instances|
|:--:|:---|:--:|
| [[L&#x2011;01]](#l01-use-ownable2step-instead-of-ownable) | Use Ownable2Step instead of Ownable | 1 |
| [[L&#x2011;02]](#l02-missing-zero-address-check-in-constructor) | Missing zero address check in constructor | 3 |
| [[L&#x2011;03]](#l03-solidity-version-0820-or-above-may-not-work-on-other-chains-due-to-push0) | Solidity version 0.8.20 or above may not work on other chains due to PUSH0 | 1 |
| [[L&#x2011;04]](#l04-vulnerable-versions-of-packages-are-being-used) | Vulnerable versions of packages are being used | 6 |
| [[L&#x2011;05]](#l05-missing-checks-for-address0-when-setting-address-state-variables) | Missing checks for `address(0)` when setting address state variables | 1 |
| [[L&#x2011;06]](#l06-variables-shadowing-other-definitions) | Variables shadowing other definitions | 1 |
| [[L&#x2011;07]](#l07-owner-can-renounce-ownership) | Owner can renounce Ownership | 1 |
| [[L&#x2011;08]](#l08-constructor--initialization-function-lacks-parameter-validation) | Constructor / initialization function lacks parameter validation | 3 |
| [[L&#x2011;09]](#l09-external-function-calls-within-loops) | External function calls within loops | 2 |
| [[L&#x2011;10]](#l10-use-safecast-to-downcast-safely) | Use `SafeCast` to downcast safely | 3 |

### Non Critical Issues

Total **117 instances** over **46 issues**:

|ID|Issue|Instances|
|:--:|:---|:--:|
| [[N&#x2011;01]](#n01-abiencodepacked-should-be-replaced-with-bytesconcat) | `abi.encodePacked()` should be replaced with `bytes.concat()` | 1 |
| [[N&#x2011;02]](#n02-import-declarations-should-import-specific-identifiers-rather-than-the-whole-file) | Import declarations should import specific identifiers, rather than the whole file | 4 |
| [[N&#x2011;03]](#n03-too-long-functions-should-be-refactored) | Too long functions should be refactored | 1 |
| [[N&#x2011;04]](#n04-there-is-no-need-to-initialize-variables-with-0) | There is no need to initialize variables with 0 | 1 |
| [[N&#x2011;05]](#n05-names-of-privateinternal-functions-should-be-prefixed-with-an-underscore) | Names of `private`/`internal` functions should be prefixed with an underscore | 5 |
| [[N&#x2011;06]](#n06-order-of-functions-does-not-follow-the-solidity-style-guide) | Order of functions does not follow the Solidity Style Guide | 1 |
| [[N&#x2011;07]](#n07-custom-errors-should-be-used-rather-than-revertrequire) | Custom errors should be used rather than `revert()`/`require()` | 2 |
| [[N&#x2011;08]](#n08-assembly-blocks-should-have-extensive-comments) | Assembly blocks should have extensive comments | 1 |
| [[N&#x2011;09]](#n09-assertshould-be-replaced-with-require-or-revert) | `assert()`Â should be replaced with `require()` or `revert()` | 1 |
| [[N&#x2011;10]](#n10-complex-casting) | Complex casting | 5 |
| [[N&#x2011;11]](#n11-contracts-should-each-be-defined-in-separate-files) | Contracts should each be defined in separate files | 1 |
| [[N&#x2011;12]](#n12-events-should-be-emitted-before-external-calls) | Events should be emitted before external calls | 1 |
| [[N&#x2011;13]](#n13-events-are-emitted-without-the-sender-information) | Events are emitted without the sender information | 2 |
| [[N&#x2011;14]](#n14-event-is-missing-indexed-fields) | Event is missing `indexed` fields | 1 |
| [[N&#x2011;15]](#n15-openzeppelincontracts-should-be-upgraded-to-a-newer-version) | @openzeppelin/contracts should be upgraded to a newer version | 1 |
| [[N&#x2011;16]](#n16-magic-numbers-should-be-replaced-with-constants) | Magic numbers should be replaced with constants | 1 |
| [[N&#x2011;17]](#n17-contracts-containing-only-utility-functions-should-be-made-into-libraries) | Contracts containing only utility functions should be made into libraries | 1 |
| [[N&#x2011;18]](#n18-contracts-should-have-natspec-author-tags) | Contracts should have NatSpec `@author` tags | 2 |
| [[N&#x2011;19]](#n19-contracts-should-have-natspec-title-tags) | Contracts should have NatSpec `@title` tags | 2 |
| [[N&#x2011;20]](#n20-event-declarations-should-have-natspec-descriptions) | Event declarations should have NatSpec descriptions | 2 |
| [[N&#x2011;21]](#n21-natspec-documentation-for-function-is-missing) | NatSpec documentation for function is missing | 8 |
| [[N&#x2011;22]](#n22-functions-missing-natspec-param-tag) | Functions missing NatSpec `@param` tag | 15 |
| [[N&#x2011;23]](#n23-public-variable-declarations-should-have-natspec-descriptions) | Public variable declarations should have NatSpec descriptions | 1 |
| [[N&#x2011;24]](#n24-functions-missing-natspec-return-tag) | Functions missing NatSpec `@return` tag | 3 |
| [[N&#x2011;25]](#n25-variables-should-be-named-in-mixedcase-style) | Variables should be named in mixedCase style | 1 |
| [[N&#x2011;26]](#n26-non-assembly-method-available) | Non-assembly method available | 1 |
| [[N&#x2011;27]](#n27-missing-zero-address-check-in-functions-with-address-parameters) | Missing zero address check in functions with address parameters | 13 |
| [[N&#x2011;28]](#n28-named-imports-of-parent-contracts-are-missing) | Named imports of parent contracts are missing | 2 |
| [[N&#x2011;29]](#n29-constants-should-be-put-on-the-left-side-of-comparisons) | Constants should be put on the left side of comparisons | 1 |
| [[N&#x2011;30]](#n30-non-interface-files-should-use-fixed-compiler-versions) | Non-interface files should use fixed compiler versions | 1 |
| [[N&#x2011;31]](#n31-high-cyclomatic-complexity) | High cyclomatic complexity | 1 |
| [[N&#x2011;32]](#n32-consider-bounding-input-array-length) | Consider bounding input array length | 1 |
| [[N&#x2011;33]](#n33-use-the-latest-solidity-version-0819-for-l2s) | Use the latest Solidity version (0.8.19 for L2s) | 1 |
| [[N&#x2011;34]](#n34-use-uint256int256-instead-of-uintint) | Use `uint256`/`int256` instead of `uint`/`int` | 2 |
| [[N&#x2011;35]](#n35-functions-with-array-parameters-should-have-length-checks-in-place) | Functions with array parameters should have length checks in place | 3 |
| [[N&#x2011;36]](#n36-contract-functions-should-use-an-interface) | Contract functions should use an `interface` | 2 |
| [[N&#x2011;37]](#n37-control-structures-do-not-follow-the-solidity-style-guide) | Control structures do not follow the Solidity Style Guide | 1 |
| [[N&#x2011;38]](#n38-missing-event-for-critical-changes) | Missing event for critical changes | 1 |
| [[N&#x2011;39]](#n39-consider-adding-emergency-stop-functionality) | Consider adding emergency-stop functionality | 1 |
| [[N&#x2011;40]](#n40-consider-adding-a-blockdeny-list) | Consider adding a block/deny-list | 2 |
| [[N&#x2011;41]](#n41-enable-ir-based-code-generation) | Enable IR-based code generation | 1 |
| [[N&#x2011;42]](#n42-functions-should-have-notice-tags) | Functions should have `@notice` tags | 8 |
| [[N&#x2011;43]](#n43-large-or-complicated-code-bases-should-implement-invariant-tests) | Large or complicated code bases should implement invariant tests | 1 |
| [[N&#x2011;44]](#n44-top-level-declarations-should-be-separated-by-at-least-two-lines) | Top-level declarations should be separated by at least two lines | 8 |
| [[N&#x2011;45]](#n45-consider-adding-formal-verification-proofs) | Consider adding formal verification proofs | 1 |
| [[N&#x2011;46]](#n46-prevent-re-setting-a-state-variable-with-the-same-value) | Prevent re-setting a state variable with the same value | 1 |

### Gas Optimizations

Total **46 instances** over **25 issues**with **5144** gas saved:

|ID|Issue|Instances|Gas|
|:--:|:---|:--:|:--:|
| [[G&#x2011;01]](#g01-constructors-can-be-marked-as-payable-to-save-deployment-gas) | Constructors can be marked as payable to save deployment gas | 2 | 42 |
| [[G&#x2011;02]](#g02-state-variables-that-are-never-modified-after-deploymentconstructor-should-be-declared-as-constant-or-immutable) | State variables that are never modified after deployment/constructor should be declared as `constant` or `immutable` | 1 | 2097 |
| [[G&#x2011;03]](#g03-using-x--x-instead-of-xx---can-save-gas) | Using `++X/`--X` instead of `X++`/`X--` can save gas | 1 | 5 |
| [[G&#x2011;04]](#g04-use-custom-errors-rather-than-revertrequire-strings-to-save-gas) | Use custom errors rather than `revert()`/`require()` strings to save gas | 2 | 100 |
| [[G&#x2011;05]](#g05-state-variables-that-are-used-multiple-times-in-a-function-should-be-cached-in-stack-variables) | State variables that are used multiple times in a function should be cached in stack variables | 7 | 679 |
| [[G&#x2011;06]](#g06-internal-functions-only-called-once-can-be-inlined-to-save-gas) | `internal` functions only called once can be inlined to save gas | 6 | 180 |
| [[G&#x2011;07]](#g07-using-this-to-access-functions-results-in-an-external-call-wasting-gas) | Using `this` to access functions results in an external call, wasting gas | 1 | 100 |
| [[G&#x2011;08]](#g08-functions-that-revert-when-called-by-normal-users-can-be-marked-payable) | Functions that revert when called by normal users can be marked `payable` | 1 | 21 |
| [[G&#x2011;09]](#g09-operator--costs-less-gas-than-operator-) | Operator `>=`/`<=` costs less gas than operator `>`/`<` | 4 | 12 |
| [[G&#x2011;10]](#g10-requirerevert-strings-longer-than-32-bytes-cost-extra-gas) | `require()`/`revert()` strings longer than 32 bytes cost extra gas | 2 | 6 |
| [[G&#x2011;11]](#g11-increments-can-be-unchecked-to-save-gas) | Increments can be `unchecked` to save gas | 1 | 60 |
| [[G&#x2011;12]](#g12-using-assembly-to-check-for-zero-can-save-gas) | Using assembly to check for zero can save gas | 1 | 6 |
| [[G&#x2011;13]](#g13-use-assembly-to-write-addresscontract-type-storage-values) | Use `assembly` to write address/contract type storage values | 1 | 50 |
| [[G&#x2011;14]](#g14-use--0-or--0-for-unsigned-integer-comparison) | Use `!= 0` or `== 0` for unsigned integer comparison | 2 | 8 |
| [[G&#x2011;15]](#g15-avoid-contract-existence-checks-by-using-low-level-calls) | Avoid contract existence checks by using low level calls | 1 | 100 |
| [[G&#x2011;16]](#g16-avoid-zero-transfer-to-save-gas) | Avoid zero transfer to save gas | 3 | 300 |
| [[G&#x2011;17]](#g17-optimize-names-to-save-gas) | Optimize names to save gas | 1 | 22 |
| [[G&#x2011;18]](#g18-reduce-gas-usage-by-moving-to-solidity-0819-or-later) | Reduce gas usage by moving to Solidity 0.8.19 or later | 1 | - |
| [[G&#x2011;19]](#g19-newer-versions-of-solidity-are-more-gas-efficient) | Newer versions of solidity are more gas efficient | 1 | - |
| [[G&#x2011;20]](#g20-avoid-updating-storage-when-the-value-hasnt-changed) | Avoid updating storage when the value hasn't changed | 1 | 800 |
| [[G&#x2011;21]](#g21-the-result-of-a-function-call-should-be-cached-rather-than-re-calling-the-function) | The result of a function call should be cached rather than re-calling the function | 1 | 100 |
| [[G&#x2011;22]](#g22-use-assembly-to-emit-events) | Use assembly to emit events | 2 | 76 |
| [[G&#x2011;23]](#g23-use-assembly-to-compute-hashes-to-save-gas) | Use assembly to compute hashes to save gas | 1 | 80 |
| [[G&#x2011;24]](#g24-use-calldata-instead-of-memory-for-immutable-arguments) | Use `calldata` instead of `memory` for immutable arguments | 1 | 300 |
| [[G&#x2011;25]](#g25-consider-activating-via-ir-for-deploying) | Consider activating via-ir for deploying | 1 | - |

### Disputed Issues

The issues below may be reported by other bots/wardens, but can be penalized/ignored since either the rule or the specified instances are invalid.

Total **52 instances** over **29 issues**:

|ID|Issue|Instances|
|:--:|:---|:--:|
| [[D&#x2011;01]](#d01-abiencodepacked-should-be-replaced-with-bytesconcat) | ~~`abi.encodePacked()` should be replaced with `bytes.concat()`~~ | 1 |
| [[D&#x2011;02]](#d02-event-names-should-use-camelcase) | ~~Event names should use CamelCase~~ | 2 |
| [[D&#x2011;03]](#d03-cast-to-bytes-or-bytes32-for-clearer-semantic-meaning) | ~~Cast to `bytes` or `bytes32` for clearer semantic meaning~~ | 2 |
| [[D&#x2011;04]](#d04-return-values-of-approve-not-checked) | ~~Return values of `approve()` not checked~~ | 1 |
| [[D&#x2011;05]](#d05-event-is-missing-indexed-fields) | ~~Event is missing `indexed` fields~~ | 1 |
| [[D&#x2011;06]](#d06-passing-abiencodepacked-with-dynamic-arguments-to-a-hash-can-cause-collisions) | ~~Passing `abi.encodePacked()` with dynamic arguments to a hash can cause collisions~~ | 1 |
| [[D&#x2011;07]](#d07-natspec-contract-declarations-should-have-notice-tags) | ~~NatSpec: Contract declarations should have `@notice` tags~~ | 2 |
| [[D&#x2011;08]](#d08-not-initializing-local-variables-to-zero-saves-gas) | ~~Not initializing local variables to zero saves gas~~ | 1 |
| [[D&#x2011;09]](#d09-safemint-should-be-used-in-place-of-mint) | ~~safeMint should be used in place of mint~~ | 1 |
| [[D&#x2011;10]](#d10-return-values-of-transfertransferfrom-not-checked) | ~~Return values of `transfer()`/`transferFrom()` not checked~~ | 3 |
| [[D&#x2011;11]](#d11-spdx-identifier-should-be-the-in-the-first-line-of-a-solidity-file) | ~~SPDX identifier should be the in the first line of a solidity file~~ | 1 |
| [[D&#x2011;12]](#d12-use--0-or--0-for-unsigned-integer-comparison) | ~~Use `!= 0` or `== 0` for unsigned integer comparison~~ | 2 |
| [[D&#x2011;13]](#d13-avoid-contract-existence-checks-by-using-low-level-calls) | ~~Avoid contract existence checks by using low level calls~~ | 6 |
| [[D&#x2011;14]](#d14-array-length-is-not-checked-before-access-its-index) | ~~Array length is not checked before access its index~~ | 1 |
| [[D&#x2011;15]](#d15-safetransfer-function-does-not-check-for-contract-existence) | ~~`safeTransfer` function does not check for contract existence~~ | 2 |
| [[D&#x2011;16]](#d16-low-level-calls-with-solidity-before-0814-result-in-an-optimiser-bug) | ~~Low level calls with solidity before 0.8.14 result in an optimiser bug~~ | 1 |
| [[D&#x2011;17]](#d17-functions-calling-contractsaddresses-with-transfer-hooks-should-be-protected-by-reentrancy-guard) | ~~Functions calling contracts/addresses with transfer hooks should be protected by reentrancy guard~~ | 3 |
| [[D&#x2011;18]](#d18-governance-functions-should-be-controlled-by-time-locks) | ~~Governance functions should be controlled by time locks~~ | 1 |
| [[D&#x2011;19]](#d19-assembly-block-creates-dirty-bits) | ~~Assembly block creates dirty bits~~ | 1 |
| [[D&#x2011;20]](#d20-calculations-should-be-memoized-rather-than-re-calculating-them) | ~~Calculations should be memoized rather than re-calculating them~~ | 2 |
| [[D&#x2011;21]](#d21-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function) | ~~`require()` or `revert()` statements that check input arguments should be at the top of the function~~ | 1 |
| [[D&#x2011;22]](#d22-some-tokens-may-revert-when-zero-value-transfers-are-made) | ~~Some tokens may revert when zero value transfers are made~~ | 3 |
| [[D&#x2011;23]](#d23-use-safecast-to-downcast-safely) | ~~Use `SafeCast` to downcast safely~~ | 1 |
| [[D&#x2011;24]](#d24-unsafe-use-of-erc20-transfertransferfrom) | ~~Unsafe use of ERC20 `transfer()`/`transferFrom()`~~ | 3 |
| [[D&#x2011;25]](#d25-use-assembly-to-compute-hashes-to-save-gas) | ~~Use assembly to compute hashes to save gas~~ | 1 |
| [[D&#x2011;26]](#d26-contracts-should-have-full-test-coverage) | ~~Contracts should have full test coverage~~ | 1 |
| [[D&#x2011;27]](#d27-use-descriptive-constant-instead-of-0-as-a-parameter) | ~~Use descriptive constant instead of 0 as a parameter~~ | 1 |
| [[D&#x2011;28]](#d28-some-tokens-may-revert-when-large-transfers-are-made) | ~~Some tokens may revert when large transfers are made~~ | 3 |
| [[D&#x2011;29]](#d29-contracts-are-vulnerable-to-rebasing-accounting-related-issues) | ~~Contracts are vulnerable to rebasing accounting-related issues~~ | 3 |

## Medium Issues

### [M&#x2011;01] Centralization risk for privileged functions


Contracts with privileged functions need owner/admin to be trusted not to perform malicious updates or drain funds. This may also cause a single point failure.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
151:     function setUri(string memory uri) external onlyOwner {
```

## Low Issues

### [L&#x2011;01] Use Ownable2Step instead of Ownable


[`Ownable2Step`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa/contracts/access/Ownable2Step.sol#L31-L56) and [`Ownable2StepUpgradeable`](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/access/Ownable2StepUpgradeable.sol#L47-L63) prevent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [L&#x2011;02] Missing zero address check in constructor


Constructors often take address parameters to initialize important components of a contract, such as owner or linked contracts. However, without a checking, there's a risk that an address parameter could be mistakenly set to the zero address (0x0). This could be due to an error or oversight during contract deployment. A zero address in a crucial role can cause serious issues, as it cannot perform actions like a normal address, and any funds sent to it will be irretrievable. It's therefore crucial to include a zero address check in constructors to prevent such potential problems. If a zero address is detected, the constructor should revert the transaction.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L44-L47](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L44-L47) ):

```solidity
/// @audit `_token not checked`
/// @audit `_delegate not checked`
16:     constructor(ERC20Votes _token, address _delegate) {

/// @audit `_token not checked`
44:     constructor(
45:         ERC20Votes _token,
46:         string memory _metadata_uri
47:     ) ERC1155(_metadata_uri) {
```

### [L&#x2011;03] Solidity version 0.8.20 or above may not work on other chains due to PUSH0


Solidity version 0.8.20 or above uses the new [Shanghai EVM](https://blog.soliditylang.org/2023/05/10/solidity-0.8.20-release-announcement/#important-note) which introduces the PUSH0 opcode. This op code may not yet be implemented on all evm-chains or Layer2s, so deployment on these chains will fail. Consider using an earlier solidity version.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L2](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2) ):

```solidity
2: pragma solidity ^0.8.2;
```

### [L&#x2011;04] Vulnerable versions of packages are being used


This project is using specific package versions which are vulnerable to the specific CVEs listed below. Consider switching to more recent versions of these packages that don't have these vulnerabilities.

- [CVE-2022-39384](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-39384) - **MEDIUM** - (`@openzeppelin/contracts >=3.2.0 <4.4.1`): OpenZeppelin Contracts is a library for secure smart contract development. Before version 4.4.1 but after 3.2.0, initializer functions that are invoked separate from contract creation (the most prominent example being minimal proxies) may be reentered if they make an untrusted non-view external call. Once an initializer has finished running it can never be re-executed. However, an exception put in place to support multiple inheritance made reentrancy possible in the scenario described above, breaking the expectation that there is a single execution. Note that upgradeable proxies are commonly initialized together with contract creation, where reentrancy is not feasible, so the impact of this issue is believed to be minor. This issue has been patched, please upgrade to version 4.4.1. As a workaround, avoid untrusted external calls during initialization.

- [CVE-2022-35961](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-35961) - **MEDIUM** - (`@openzeppelin/contracts >=4.1.0 <4.7.3`): OpenZeppelin Contracts is a library for secure smart contract development. The functions `ECDSA.recover` and `ECDSA.tryRecover` are vulnerable to a kind of signature malleability due to accepting EIP-2098 compact signatures in addition to the traditional 65 byte signature format. This is only an issue for the functions that take a single `bytes` argument, and not the functions that take `r, v, s` or `r, vs` as separate arguments. The potentially affected contracts are those that implement signature reuse or replay protection by marking the signature itself as used rather than the signed message or a nonce included in it. A user may take a signature that has already been submitted, submit it again in a different form, and bypass this protection. The issue has been patched in 4.7.3.

- [CVE-2022-35915](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-35915) - **MEDIUM** - (`@openzeppelin/contracts >=2.0.0 <4.7.2`): OpenZeppelin Contracts is a library for secure smart contract development. The target contract of an EIP-165 `supportsInterface` query can cause unbounded gas consumption by returning a lot of data, while it is generally assumed that this operation has a bounded cost. The issue has been fixed in v4.7.2. Users are advised to upgrade. There are no known workarounds for this issue.

- [CVE-2022-31198](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-31198) - **HIGH** - (`@openzeppelin/contracts >=4.3.0 <4.7.2`): OpenZeppelin Contracts is a library for secure smart contract development. This issue concerns instances of Governor that use the module `GovernorVotesQuorumFraction`, a mechanism that determines quorum requirements as a percentage of the voting token's total supply. In affected instances, when a proposal is passed to lower the quorum requirements, past proposals may become executable if they had been defeated only due to lack of quorum, and the number of votes it received meets the new quorum requirement. Analysis of instances on chain found only one proposal that met this condition, and we are actively monitoring for new occurrences of this particular issue. This issue has been patched in v4.7.2. Users are advised to upgrade. Users unable to upgrade should consider avoiding lowering quorum requirements if a past proposal was defeated for lack of quorum.

- [CVE-2022-31172](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-31172) - **HIGH** - (`@openzeppelin/contracts >=4.1.0 <4.7.1`): OpenZeppelin Contracts is a library for smart contract development. Versions 4.1.0 until 4.7.1 are vulnerable to the SignatureChecker reverting. `SignatureChecker.isValidSignatureNow` is not expected to revert. However, an incorrect assumption about Solidity 0.8's `abi.decode` allows some cases to revert, given a target contract that doesn't implement EIP-1271 as expected. The contracts that may be affected are those that use `SignatureChecker` to check the validity of a signature and handle invalid signatures in a way other than reverting. The issue was patched in version 4.7.1.

- [CVE-2022-31170](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-31170) - **HIGH** - (`@openzeppelin/contracts >=4.0.0 <4.7.1`): OpenZeppelin Contracts is a library for smart contract development. Versions 4.0.0 until 4.7.1 are vulnerable to ERC165Checker reverting instead of returning `false`. `ERC165Checker.supportsInterface` is designed to always successfully return a boolean, and under no circumstance revert. However, an incorrect assumption about Solidity 0.8's `abi.decode` allows some cases to revert, given a target contract that doesn't implement EIP-165 as expected, specifically if it returns a value other than 0 or 1. The contracts that may be affected are those that use `ERC165Checker` to check for support for an interface and then handle the lack of support in a way other than reverting. The issue was patched in version 4.7.1.

There are 6 instances:

- Global finding

### [L&#x2011;05] Missing checks for `address(0)` when setting address state variables


There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L48](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L48) ):

```solidity
48:         token = _token;
```

### [L&#x2011;06] Variables shadowing other definitions


A variable declaration shadowing any other existing definition is error-prone. It can cause confusion for developers, potentially introduce bugs, and reduce the readability and maintainability.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
/// @audit Shadows `function uri()`
151:     function setUri(string memory uri) external onlyOwner {
```

### [L&#x2011;07] Owner can renounce Ownership


Each of the following contracts implements or inherits the `renounceOwnership()` function. This can represent a certain risk if the ownership is renounced for any other reason than by design. Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [L&#x2011;08] Constructor / initialization function lacks parameter validation


Constructors and initialization functions play a critical role in contracts by setting important initial states when the contract is first deployed before the system starts. The parameters passed to the constructor and initialization functions directly affect the behavior of the contract / protocol. If incorrect parameters are provided, the system may fail to run, behave abnormally, be unstable, or lack security. Therefore, it's crucial to carefully check each parameter in the constructor and initialization functions. If an exception is found, the transaction should be rolled back.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L44-L47](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L44-L47) ):

```solidity
/// @audit `_token`
/// @audit `_delegate`
16:     constructor(ERC20Votes _token, address _delegate) {

/// @audit `_token`
44:     constructor(
45:         ERC20Votes _token,
46:         string memory _metadata_uri
47:     ) ERC1155(_metadata_uri) {
```

### [L&#x2011;09] External function calls within loops


Calling external functions within loops can easily result in insufficient gas. This greatly increases the likelihood of transaction failures, DOS attacks, and other unexpected actions. It is recommended to limit the number of loops within loops that call external functions, and to limit the gas line for each external call.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L103](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L103), [#L106](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L106) ):

```solidity
/// @audit Calling `_reimburse()` within `for` loop, it will trigger an external call - `transferFrom()`
103:                 _reimburse(source, amount);

/// @audit Calling `createProxyDelegatorAndTransfer()` within `for` loop, it will trigger an external call - `transferFrom()`
106:                 createProxyDelegatorAndTransfer(target, amount);
```

### [L&#x2011;10] Use `SafeCast` to downcast safely


When a type is downcast to a smaller type, the higher order bits are truncated, effectively applying a modulo to the original value. The loss of data may cause incorrect calculations, unexpected state changes, or other unexpected behavior.
It is recommended to use the [SafeCast library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol).

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L91](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L91), [#L94](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L94), [#L214](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L214) ):

```solidity
/// @audit uint256 -> uint160
91:                 ? address(uint160(sources[transferIndex]))

/// @audit uint256 -> uint160
94:                 ? address(uint160(targets[transferIndex]))

/// @audit uint256 -> uint160
214:         return address(uint160(uint256(hash)));
```

## Non Critical Issues

### [N&#x2011;01] `abi.encodePacked()` should be replaced with `bytes.concat()`


Solidity version 0.8.4 introduces `bytes.concat()`, which can be used to replace `abi.encodePacked()` on bytes/strings. It can make the intended operation clearer, leading to less reviewer confusion.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L202-L205](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L202-L205) ):

```solidity
202:         bytes memory bytecode = abi.encodePacked(
203:             type(ERC20ProxyDelegator).creationCode, 
204:             abi.encode(_token, _delegate)
205:         );
```

### [N&#x2011;02] Import declarations should import specific identifiers, rather than the whole file


Using import declarations of the form `import {<identifier_name>} from "some/file.sol"` avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation (but does not save any gas).

There are 4 instances:

- *ERC20MultiDelegate.sol* ( [#L6](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L6), [#L7](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L7), [#L8](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L8), [#L9](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L9) ):

```solidity
6: import "@openzeppelin/contracts/access/Ownable.sol";

7: import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

8: import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";

9: import "@openzeppelin/contracts/utils/math/Math.sol";
```

### [N&#x2011;03] Too long functions should be refactored


Functions with too many lines are difficult to understand. It is recommended to refactor complex functions into multiple shorter and easier to understand functions.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L65](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65) ):

```solidity
/// @audit 52 lines
65:     function _delegateMulti(
```

### [N&#x2011;04] There is no need to initialize variables with 0


Since the variables are automatically set to 0 when created, it is redundant to initialize it with 0 again.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L86](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L86) ):

```solidity
86:             uint transferIndex = 0;
```

### [N&#x2011;05] Names of `private`/`internal` functions should be prefixed with an underscore


It is recommended by the [Solidity Style Guide](https://docs.soliditylang.org/en/v0.8.20/style-guide.html#underscore-prefix-for-non-external-functions-and-variables).

There are 5 instances:

- *ERC20MultiDelegate.sol* ( [#L155-L158](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155-L158), [#L163-L167](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163-L167), [#L173-L175](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173-L175), [#L192-L194](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192-L194), [#L198-L201](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198-L201) ):

```solidity
155:     function createProxyDelegatorAndTransfer(
156:         address target,
157:         uint256 amount
158:     ) internal {

163:     function transferBetweenDelegators(
164:         address from,
165:         address to,
166:         uint256 amount
167:     ) internal {

173:     function deployProxyDelegatorIfNeeded(
174:         address delegate
175:     ) internal returns (address) {

192:     function getBalanceForDelegate(
193:         address delegate
194:     ) internal view returns (uint256) {

198:     function retrieveProxyContractAddress(
199:         ERC20Votes _token,
200:         address _delegate
201:     ) private view returns (address) {
```

### [N&#x2011;06] Order of functions does not follow the Solidity Style Guide


According to the [Solidity Style Guide](https://docs.soliditylang.org/en/v0.8.20/style-guide.html#order-of-functions), functions should be grouped according to their visibility and ordered: `constructor`, `receive`, `fallback`, `external`, `public`, `internal`, `private`. Within a grouping, place the view and pure functions last.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L144](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L144), [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
/// @audit ââ Out of order with `setUri()`
144:     function _reimburse(address source, uint256 amount) internal {

/// @audit ââ Out of order with `_reimburse()`
151:     function setUri(string memory uri) external onlyOwner {
```

### [N&#x2011;07] Custom errors should be used rather than `revert()`/`require()`


Custom errors are available from solidity version 0.8.4. Custom errors are more easily processed in try-catch blocks, and are easier to re-use and maintain.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L74-L77](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L74-L77), [#L79-L82](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L79-L82) ):

```solidity
74:         require(
75:             sourcesLength > 0 || targetsLength > 0,
76:             "Delegate: You should provide at least one source or one target delegate"
77:         );

79:         require(
80:             Math.max(sourcesLength, targetsLength) == amountsLength,
81:             "Delegate: The number of amounts must be equal to the greater of the number of sources or targets"
82:         );
```

### [N&#x2011;08] Assembly blocks should have extensive comments


Assembly blocks take a lot more time to audit than normal Solidity code, and often have gotchas and side-effects that the Solidity versions of the same code do not. Consider adding more comments explaining what is being done in every step of the assembly code, and describe why assembly is being used instead of Solidity.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L180-L182](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L180-L182) ):

```solidity
180:         assembly {
181:             bytecodeSize := extcodesize(proxyAddress)
182:         }
```

### [N&#x2011;09] `assert()`Â should be replaced with `require()` or `revert()`


In versions of Solidity prior to 0.8.0, when encountering an assert all the remaining gas will be consumed.
Even after solidity 0.8.0, the assert function is still not recommended, as described in the [documentation](https://docs.soliditylang.org/en/v0.8.20/control-structures.html#panic-via-assert-and-error-via-require):
> Assert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L131](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L131) ):

```solidity
131:         assert(amount <= balance);
```

### [N&#x2011;10] Complex casting


Consider whether the number of casts is really necessary, or whether using a different type would be more appropriate. Alternatively, add comments to explain in detail why the casts are necessary, and any implicit reasons why the cast does not introduce an overflow.

There are 5 instances:

- *ERC20MultiDelegate.sol* ( [#L91](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L91), [#L94](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L94), [#L195](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L195), [#L214](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L214), [#L214](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L214) ):

```solidity
91:                 ? address(uint160(sources[transferIndex]))

94:                 ? address(uint160(targets[transferIndex]))

195:         return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));

214:         return address(uint160(uint256(hash)));

214:         return address(uint160(uint256(hash)));
```

### [N&#x2011;11] Contracts should each be defined in separate files


Keeping each contract in a separate file makes it easier to work with multiple people, makes the code easier to maintain, and is a common practice on most projects. The following files each contains more than one contract/library/interface.

There is 1 instance:

- [*ERC20MultiDelegate.sol*](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol)

### [N&#x2011;12] Events should be emitted before external calls


Ensure that events follow the best practice of check-effects-interaction, and are emitted before external calls.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L136](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L136) ):

```solidity
/// @audit `deployProxyDelegatorIfNeeded()` is called on line 133
136:         emit DelegationProcessed(source, target, amount);
```

### [N&#x2011;13] Events are emitted without the sender information


When an action is triggered based on a user's action, not being able to filter based on who triggered the action makes event processing a lot more cumbersome. Including the `msg.sender` the events of these types of action will make events much more useful to end users, especially when `msg.sender` is not `tx.origin`.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L136](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L136), [#L187](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L187) ):

```solidity
136:         emit DelegationProcessed(source, target, amount);

187:             emit ProxyDeployed(delegate, proxyAddress);
```

### [N&#x2011;14] Event is missing `indexed` fields


Index event fields makes the field more quickly accessible to [off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each indexed field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L32](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L32) ):

```solidity
32:     event ProxyDeployed(address indexed delegate, address proxyAddress);
```

### [N&#x2011;15] @openzeppelin/contracts should be upgraded to a newer version


These contracts import contracts from `@openzeppelin/contracts`, but they are not using [the latest version](https://github.com/OpenZeppelin/openzeppelin-contracts/releases).

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L4](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L4) ):

```solidity
4: import {Address} from "@openzeppelin/contracts/utils/Address.sol";
```

### [N&#x2011;16] Magic numbers should be replaced with constants


Magic numbers are hard-coded values in code that can make it difficult for developers and maintainers to understand the code, and can also cause confusion or errors. To improve the readability and maintainability of code, it is recommended to replace magic numbers with constants that have good readability.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L208](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L208) ):

```solidity
/// @audit 0xff
208:                 bytes1(0xff),
```

### [N&#x2011;17] Contracts containing only utility functions should be made into libraries


There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L15](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L15) ):

```solidity
15: contract ERC20ProxyDelegator {
```

### [N&#x2011;18] Contracts should have NatSpec `@author` tags


There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L15](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L15), [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
15: contract ERC20ProxyDelegator {

25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [N&#x2011;19] Contracts should have NatSpec `@title` tags


Some contract definitions have an incomplete NatSpec: add a `@title` notation to describe the contract to improve the code documentation.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L15](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L15), [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
15: contract ERC20ProxyDelegator {

25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [N&#x2011;20] Event declarations should have NatSpec descriptions


There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L32](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L32), [#L33-L37](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L33-L37) ):

```solidity
32:     event ProxyDeployed(address indexed delegate, address proxyAddress);

33:     event DelegationProcessed(
34:         address indexed from,
35:         address indexed to,
36:         uint256 amount
37:     );
```

### [N&#x2011;21] NatSpec documentation for function is missing


It is recommended that Solidity contracts are fully annotated using NatSpec for all public interfaces (everything in the ABI). It is clearly stated in the Solidity official documentation.
In complex projects such as DeFi, the interpretation of all functions and their arguments and returns is important for code readability and auditability.

There are 8 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L65](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65), [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151), [#L155](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155), [#L163](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163), [#L173](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173), [#L192](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192), [#L198](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198) ):

```solidity
16:     constructor(ERC20Votes _token, address _delegate) {

65:     function _delegateMulti(

151:     function setUri(string memory uri) external onlyOwner {

155:     function createProxyDelegatorAndTransfer(

163:     function transferBetweenDelegators(

173:     function deployProxyDelegatorIfNeeded(

192:     function getBalanceForDelegate(

198:     function retrieveProxyContractAddress(
```

### [N&#x2011;22] Functions missing NatSpec `@param` tag


<details>
<summary>There are 15 instances (click to show):</summary>

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L65-L69](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65-L69), [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151), [#L155-L158](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155-L158), [#L163-L167](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163-L167), [#L173-L175](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173-L175), [#L192-L194](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192-L194), [#L198-L201](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198-L201) ):

```solidity
/// @audit Missing @param for `_token`, `_delegate`
16:     constructor(ERC20Votes _token, address _delegate) {

/// @audit Missing @param for `sources`, `targets`, `amounts`
65:     function _delegateMulti(
66:         uint256[] calldata sources,
67:         uint256[] calldata targets,
68:         uint256[] calldata amounts
69:     ) internal {

/// @audit Missing @param for `uri`
151:     function setUri(string memory uri) external onlyOwner {

/// @audit Missing @param for `target`, `amount`
155:     function createProxyDelegatorAndTransfer(
156:         address target,
157:         uint256 amount
158:     ) internal {

/// @audit Missing @param for `from`, `to`, `amount`
163:     function transferBetweenDelegators(
164:         address from,
165:         address to,
166:         uint256 amount
167:     ) internal {

/// @audit Missing @param for `delegate`
173:     function deployProxyDelegatorIfNeeded(
174:         address delegate
175:     ) internal returns (address) {

/// @audit Missing @param for `delegate`
192:     function getBalanceForDelegate(
193:         address delegate
194:     ) internal view returns (uint256) {

/// @audit Missing @param for `_token`, `_delegate`
198:     function retrieveProxyContractAddress(
199:         ERC20Votes _token,
200:         address _delegate
201:     ) private view returns (address) {
```

</details>

### [N&#x2011;23] Public variable declarations should have NatSpec descriptions


It is [recommended](https://docs.soliditylang.org/en/v0.8.20/natspec-format.html#tags) to use the NatSpec tags `@notice`, `@dev`, `@return`, `@inheritdoc` for public state variables.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L28](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L28) ):

```solidity
28:     ERC20Votes public token;
```

### [N&#x2011;24] Functions missing NatSpec `@return` tag


There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L173-L175](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173-L175), [#L192-L194](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192-L194), [#L198-L201](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198-L201) ):

```solidity
173:     function deployProxyDelegatorIfNeeded(
174:         address delegate
175:     ) internal returns (address) {

192:     function getBalanceForDelegate(
193:         address delegate
194:     ) internal view returns (uint256) {

198:     function retrieveProxyContractAddress(
199:         ERC20Votes _token,
200:         address _delegate
201:     ) private view returns (address) {
```

### [N&#x2011;25] Variables should be named in mixedCase style


As the [Solidity Style Guide](https://docs.soliditylang.org/en/latest/style-guide.html#naming-styles) suggests: arguments, local variables and mutable state variables should be named in mixedCase style.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L46](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L46) ):

```solidity
/// @audit _metadata_uri
46:         string memory _metadata_uri
```

### [N&#x2011;26] Non-assembly method available


There are some automated tools that will flag a project as having higher complexity if there is inline-assembly, so it's best to avoid using it where it's not necessary. In addition, most assembly methods can be replaced by non-assembly methods, for example:
- `assembly{ g := gas() }` => `uint256 g = gasleft()`
- `assembly{ id := chainid() }` => `uint256 id = block.chainid`
- `assembly { r := mulmod(a, b, d) }` => `uint256 m = mulmod(x, y, k)`
- `assembly { size := extcodesize() }` => `uint256 size = address(a).code.length`
- etc.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L181](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L181) ):

```solidity
181:             bytecodeSize := extcodesize(proxyAddress)
```

### [N&#x2011;27] Missing zero address check in functions with address parameters


Adding a zero address check for each address type parameter can prevent errors.

<details>
<summary>There are 13 instances (click to show):</summary>

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L44-L47](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L44-L47), [#L124-L128](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L124-L128), [#L144](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L144), [#L155-L158](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155-L158), [#L163-L167](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163-L167), [#L173-L175](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173-L175), [#L192-L194](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192-L194), [#L198-L201](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198-L201) ):

```solidity
/// @audit `_token not checked`
/// @audit `_delegate not checked`
16:     constructor(ERC20Votes _token, address _delegate) {

/// @audit `_token not checked`
44:     constructor(
45:         ERC20Votes _token,
46:         string memory _metadata_uri
47:     ) ERC1155(_metadata_uri) {

/// @audit `source not checked`
/// @audit `target not checked`
124:     function _processDelegation(
125:         address source,
126:         address target,
127:         uint256 amount
128:     ) internal {

/// @audit `source not checked`
144:     function _reimburse(address source, uint256 amount) internal {

/// @audit `target not checked`
155:     function createProxyDelegatorAndTransfer(
156:         address target,
157:         uint256 amount
158:     ) internal {

/// @audit `from not checked`
/// @audit `to not checked`
163:     function transferBetweenDelegators(
164:         address from,
165:         address to,
166:         uint256 amount
167:     ) internal {

/// @audit `delegate not checked`
173:     function deployProxyDelegatorIfNeeded(
174:         address delegate
175:     ) internal returns (address) {

/// @audit `delegate not checked`
192:     function getBalanceForDelegate(
193:         address delegate
194:     ) internal view returns (uint256) {

/// @audit `_token not checked`
/// @audit `_delegate not checked`
198:     function retrieveProxyContractAddress(
199:         ERC20Votes _token,
200:         address _delegate
201:     ) private view returns (address) {
```

</details>

### [N&#x2011;28] Named imports of parent contracts are missing


There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
/// @audit ERC1155
/// @audit Ownable
25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [N&#x2011;29] Constants should be put on the left side of comparisons


Putting constants on the left side of comparison statements is a best practice known as [Yoda conditions](https://en.wikipedia.org/wiki/Yoda_conditions).
Although solidity's static typing system prevents accidental assignments within conditionals, adopting this practice can improve code readability and consistency, especially when working across multiple languages.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L185](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L185) ):

```solidity
/// @audit put `0` on the left
185:         if (bytecodeSize == 0) {
```

### [N&#x2011;30] Non-interface files should use fixed compiler versions


To prevent the actual contracts being deployed from behaving differently depending on the compiler version, it is recommended to use fixed solidity versions for contracts and libraries.

Although we can configure a specific version through config (like hardhat, forge config files), it is recommended to **set the fixed version in the solidity pragma directly** before deploying to the mainnet.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L2](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2) ):

```solidity
2: pragma solidity ^0.8.2;
```

### [N&#x2011;31] High cyclomatic complexity


Consider breaking down these blocks into more manageable units, by splitting things into utility functions, by reducing nesting, and by using early returns.

<details>
<summary>There is 1 instance (click to show):</summary>

- *ERC20MultiDelegate.sol* ( [#L65-L116](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65-L116) ):

```solidity
65:     function _delegateMulti(
66:         uint256[] calldata sources,
67:         uint256[] calldata targets,
68:         uint256[] calldata amounts
69:     ) internal {
70:         uint256 sourcesLength = sources.length;
71:         uint256 targetsLength = targets.length;
72:         uint256 amountsLength = amounts.length;
73: 
74:         require(
75:             sourcesLength > 0 || targetsLength > 0,
76:             "Delegate: You should provide at least one source or one target delegate"
77:         );
78: 
79:         require(
80:             Math.max(sourcesLength, targetsLength) == amountsLength,
81:             "Delegate: The number of amounts must be equal to the greater of the number of sources or targets"
82:         );
83: 
84:         // Iterate until all source and target delegates have been processed.
85:         for (
86:             uint transferIndex = 0;
87:             transferIndex < Math.max(sourcesLength, targetsLength);
88:             transferIndex++
89:         ) {
...... OMITTED ......
92:                 : address(0);
93:             address target = transferIndex < targetsLength
94:                 ? address(uint160(targets[transferIndex]))
95:                 : address(0);
96:             uint256 amount = amounts[transferIndex];
97: 
98:             if (transferIndex < Math.min(sourcesLength, targetsLength)) {
99:                 // Process the delegation transfer between the current source and target delegate pair.
100:                 _processDelegation(source, target, amount);
101:             } else if (transferIndex < sourcesLength) {
102:                 // Handle any remaining source amounts after the transfer process.
103:                 _reimburse(source, amount);
104:             } else if (transferIndex < targetsLength) {
105:                 // Handle any remaining target amounts after the transfer process.
106:                 createProxyDelegatorAndTransfer(target, amount);
107:             }
108:         }
109: 
110:         if (sourcesLength > 0) {
111:             _burnBatch(msg.sender, sources, amounts[:sourcesLength]);
112:         }
113:         if (targetsLength > 0) {
114:             _mintBatch(msg.sender, targets, amounts[:targetsLength], "");
115:         }
116:     }
```

</details>

### [N&#x2011;32] Consider bounding input array length


The functions below take in an unbounded array, and make function calls for entries in the array. While the function will revert if it eventually runs out of gas, it may be a nicer user experience to require() that the length of the array is below some reasonable maximum, so that the user doesn't have to use up a full transaction's gas only to see that the transaction reverts.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L85](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L85) ):

```solidity
85:         for (
```

### [N&#x2011;33] Use the latest Solidity version (0.8.19 for L2s)


Upgrading to the latest solidity version can optimize gas usage, take advantage of new features and improve overall contract efficiency. Where possible, based on compatibility requirements, it is recommended to use newer/latest solidity version to take advantage of the latest optimizations and features.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L2](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2) ):

```solidity
2: pragma solidity ^0.8.2;
```

### [N&#x2011;34] Use `uint256`/`int256` instead of `uint`/`int`


It is recommended to use `uint256`/`int256` instead of `uint`/`int` in function parameters, since they are used for function signatures.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L86](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L86), [#L179](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L179) ):

```solidity
/// @audit uint transferIndex
86:             uint transferIndex = 0;

/// @audit uint bytecodeSize
179:         uint bytecodeSize;
```

### [N&#x2011;35] Functions with array parameters should have length checks in place


There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L57-L60](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L57-L60) ):

```solidity
/// @audit sources
/// @audit targets
/// @audit amounts
57:     function delegateMulti(
58:         uint256[] calldata sources,
59:         uint256[] calldata targets,
60:         uint256[] calldata amounts
```

### [N&#x2011;36] Contract functions should use an `interface`


All `external`/`public` functions should extend an `interface`. This is useful to ensure that the whole API is extracted and can be more easily integrated by other projects.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L57-L61](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L57-L61), [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
57:     function delegateMulti(
58:         uint256[] calldata sources,
59:         uint256[] calldata targets,
60:         uint256[] calldata amounts
61:     ) external {

151:     function setUri(string memory uri) external onlyOwner {
```

### [N&#x2011;37] Control structures do not follow the Solidity Style Guide


Refer to the [Solidity style guide - Control Structures](https://docs.soliditylang.org/en/v0.8.20/style-guide.html#control-structures).

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L85](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L85) ):

```solidity
85:         for (
```

### [N&#x2011;38] Missing event for critical changes


Events should be emitted when critical changes are made to the contracts.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151-L153](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151-L153) ):

```solidity
151:     function setUri(string memory uri) external onlyOwner {
152:         _setURI(uri);
153:     }
```

### [N&#x2011;39] Consider adding emergency-stop functionality


Adding a way to quickly halt protocol functionality in an emergency, rather than having to pause individual contracts one-by-one, will make in-progress hack mitigation faster and much less stressful.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [N&#x2011;40] Consider adding a block/deny-list


Doing so will significantly increase centralization, but will help to prevent hackers from using stolen tokens

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L15](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L15), [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
15: contract ERC20ProxyDelegator {

25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [N&#x2011;41] Enable IR-based code generation


The IR-based code generator was introduced with an aim to not only allow code generation to be more transparent and auditable but also to enable more powerful optimization passes that span across functions.
You can enable it on the command line using `--via-ir` or with the option `{"viaIR": true}`.
This will take longer to compile, but you can just simple test it before deploying and if you got a better benchmark then you can add --via-ir to your deploy command
More on: https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html

There is 1 instance:

- Global finding

### [N&#x2011;42] Functions should have `@notice` tags


The `@notice` is used to explain to users what the function does. The compiler interprets `///` or `/**` comments [as this tag](https://docs.soliditylang.org/en/latest/natspec-format.html#tags) if one wasn't explicitly provided.

There are 8 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L65](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65), [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151), [#L155](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155), [#L163](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163), [#L173](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173), [#L192](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192), [#L198](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L198) ):

```solidity
16:     constructor(ERC20Votes _token, address _delegate) {

65:     function _delegateMulti(

151:     function setUri(string memory uri) external onlyOwner {

155:     function createProxyDelegatorAndTransfer(

163:     function transferBetweenDelegators(

173:     function deployProxyDelegatorIfNeeded(

192:     function getBalanceForDelegate(

198:     function retrieveProxyContractAddress(
```

### [N&#x2011;43] Large or complicated code bases should implement invariant tests


This includes: large code bases, or code with lots of inline-assembly, complicated math, or complicated interactions between multiple contracts.
Invariant fuzzers such as Echidna require the test writer to come up with invariants which should not be violated under any circumstances, and the fuzzer tests various inputs and function calls to ensure that the invariants always hold.
Even code with 100% code coverage can still have bugs due to the order of the operations a user performs, and invariant fuzzers may help significantly.

There is 1 instance:

- Global finding

### [N&#x2011;44] Top-level declarations should be separated by at least two lines


<details>
<summary>There are 8 instances (click to show):</summary>

- *ERC20MultiDelegate.sol* ( [#L2-L4](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2-L4), [#L63-L65](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L63-L65), [#L149-L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L149-L151), [#L153-L155](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L153-L155), [#L161-L163](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L161-L163), [#L171-L173](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L171-L173), [#L190-L192](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L190-L192), [#L196-L198](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L196-L198) ):

```solidity
2: pragma solidity ^0.8.2;
3: 
4: import {Address} from "@openzeppelin/contracts/utils/Address.sol";

63:     }
64: 
65:     function _delegateMulti(

149:     }
150: 
151:     function setUri(string memory uri) external onlyOwner {

153:     }
154: 
155:     function createProxyDelegatorAndTransfer(

161:     }
162: 
163:     function transferBetweenDelegators(

171:     }
172: 
173:     function deployProxyDelegatorIfNeeded(

190:     }
191: 
192:     function getBalanceForDelegate(

196:     }
197: 
198:     function retrieveProxyContractAddress(
```

</details>

### [N&#x2011;45] Consider adding formal verification proofs


Formal verification is the act of proving or disproving the correctness of intended algorithms underlying a system with respect to a certain formal specification/property/invariant, using formal methods of mathematics.

Some tools that are currently available to perform these tests on smart contracts are [SMTChecker](https://docs.soliditylang.org/en/latest/smtchecker.html) and [Certora Prover](https://www.certora.com/).

There is 1 instance:

- [*ERC20MultiDelegate.sol*](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol)

### [N&#x2011;46] Prevent re-setting a state variable with the same value


This especially problematic when the setter also emits the same value, which may be confusing to offline parsers.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L152](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L152) ):

```solidity
152:         _setURI(uri);
```

## Gas Optimizations

### [G&#x2011;01] Constructors can be marked as payable to save deployment gas


Payable functions cost less gas to execute, because the compiler does not have to add extra checks to ensure that no payment is provided. A constructor can be safely marked as payable, because only the deployer would be able to pass funds, and the project itself would not pass any funds.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L44-L47](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L44-L47) ):

```solidity
16:     constructor(ERC20Votes _token, address _delegate) {

44:     constructor(
45:         ERC20Votes _token,
46:         string memory _metadata_uri
47:     ) ERC1155(_metadata_uri) {
```

### [G&#x2011;02] State variables that are never modified after deployment/constructor should be declared as `constant` or `immutable`


This can avoid a Gsset (**20000 gas**) on deployment (in constructor), and replaces the first access in each transaction (Gcoldsload - **2100 gas**) and each access thereafter (Gwarmacces - **100 gas**) with a `PUSH32` (**3 gas**).
While `string`s are not value types, and therefore cannot be `immutable`/`constant` if not hard-coded outside of the constructor, the same behavior can be achieved by making the current contract `abstract` with `virtual` functions for the `string` accessors, and having a child contract override the functions with the hard-coded implementation-specific values.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L28](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L28) ):

```solidity
28:     ERC20Votes public token;
```

### [G&#x2011;03] Using `++X/`--X` instead of `X++`/`X--` can save gas


It can save 5 gas for each execution / per iteration.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L88](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L88) ):

```solidity
88:             transferIndex++
```

### [G&#x2011;04] Use custom errors rather than `revert()`/`require()` strings to save gas


Custom errors are available from solidity version 0.8.4. Custom errors save [**~50 gas**](https://gist.github.com/IllIllI000/ad1bd0d29a0101b25e57c293b4b0c746) each time they're hit by [avoiding having to allocate and store the revert string](https://blog.soliditylang.org/2021/04/21/custom-errors/#errors-in-depth). Not defining the strings also save deployment gas.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L74-L77](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L74-L77), [#L79-L82](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L79-L82) ):

```solidity
74:         require(
75:             sourcesLength > 0 || targetsLength > 0,
76:             "Delegate: You should provide at least one source or one target delegate"
77:         );

79:         require(
80:             Math.max(sourcesLength, targetsLength) == amountsLength,
81:             "Delegate: The number of amounts must be equal to the greater of the number of sources or targets"
82:         );
```

### [G&#x2011;05] State variables that are used multiple times in a function should be cached in stack variables


When performing multiple operations on a state variable in a function, it is recommended to cache it first. Either multiple reads or multiple writes to a state variable can save gas by caching it on the stack.
Caching of a state variable replaces each Gwarmaccess (100 gas) with a much cheaper stack read. Other less obvious fixes/optimizations include having local memory caches of state variable structs, or having local caches of state variable contracts/addresses.
*Saves 100 gas per instance*.

There are 7 instances:

- *ERC20MultiDelegate.sol* ( [#L144](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L144), [#L163](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163), [#L173](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L173) ):

```solidity
/// @audit token: 2 reads
144:     function _reimburse(address source, uint256 amount) internal {

/// @audit token: 3 reads
163:     function transferBetweenDelegators(

/// @audit token: 2 reads
173:     function deployProxyDelegatorIfNeeded(
```

### [G&#x2011;06] `internal` functions only called once can be inlined to save gas


If an `internal` function is only used once, there is no need to modularize it, unless the function calling it would otherwise be too long and complex. Not inlining costs 20 to 40 gas because of two extra JUMP instructions and additional stack operations needed for function calls.

<details>
<summary>There are 6 instances (click to show):</summary>

- *ERC20MultiDelegate.sol* ( [#L65-L69](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65-L69), [#L124-L128](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L124-L128), [#L144](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L144), [#L155-L158](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155-L158), [#L163-L167](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163-L167), [#L192-L194](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L192-L194) ):

```solidity
65:     function _delegateMulti(
66:         uint256[] calldata sources,
67:         uint256[] calldata targets,
68:         uint256[] calldata amounts
69:     ) internal {

124:     function _processDelegation(
125:         address source,
126:         address target,
127:         uint256 amount
128:     ) internal {

144:     function _reimburse(address source, uint256 amount) internal {

155:     function createProxyDelegatorAndTransfer(
156:         address target,
157:         uint256 amount
158:     ) internal {

163:     function transferBetweenDelegators(
164:         address from,
165:         address to,
166:         uint256 amount
167:     ) internal {

192:     function getBalanceForDelegate(
193:         address delegate
194:     ) internal view returns (uint256) {
```

</details>

### [G&#x2011;07] Using `this` to access functions results in an external call, wasting gas


External calls have an overhead of **100 gas**, which can be avoided by not referencing the function using `this`. Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents' functions and change the visibility from `external` to `public`, so make this change if it's required in order to call the function internally.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L195](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L195) ):

```solidity
195:         return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));
```

### [G&#x2011;08] Functions that revert when called by normal users can be marked `payable`


If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.
The extra opcodes avoided are: 
`CALLVALUE(2), DUP1(3), ISZERO(3), PUSH2(3), JUMPI(10), PUSH1(3), DUP1(3), REVERT(0), JUMPDEST(1), POP(2)` 
which cost an average of about 21 gas per call to the function, in addition to the extra deployment cost.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
151:     function setUri(string memory uri) external onlyOwner {
```

### [G&#x2011;09] Operator `>=`/`<=` costs less gas than operator `>`/`<`


The compiler uses opcodes `GT` and `ISZERO` for code that uses `>`, but only requires `LT` for `>=`. A similar behavior applies for `>`, which uses opcodes `LT` and `ISZERO`, but only requires `GT` for `<=`. It can [save **3 gas**](https://gist.github.com/IllIllI000/3dc79d25acccfa16dee4e83ffdc6ffde) for each.
It should be converted to the `<=`/`>=` equivalent when comparing against integer literals.

There are 4 instances:

- *ERC20MultiDelegate.sol* ( [#L75](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L75), [#L75](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L75), [#L110](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L110), [#L113](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L113) ):

```solidity
75:             sourcesLength > 0 || targetsLength > 0,

75:             sourcesLength > 0 || targetsLength > 0,

110:         if (sourcesLength > 0) {

113:         if (targetsLength > 0) {
```

### [G&#x2011;10] `require()`/`revert()` strings longer than 32 bytes cost extra gas


Each extra memory word of bytes past the original 32 [incurs an MSTORE](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#consider-having-short-revert-strings) which costs **3 gas**

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L74-L77](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L74-L77), [#L79-L82](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L79-L82) ):

```solidity
74:         require(
75:             sourcesLength > 0 || targetsLength > 0,
76:             "Delegate: You should provide at least one source or one target delegate"
77:         );

79:         require(
80:             Math.max(sourcesLength, targetsLength) == amountsLength,
81:             "Delegate: The number of amounts must be equal to the greater of the number of sources or targets"
82:         );
```

### [G&#x2011;11] Increments can be `unchecked` to save gas


Using `unchecked` increments can save gas by bypassing the built-in overflow checks. This can save [30-40 gas](https://gist.github.com/hrkrshnn/ee8fabd532058307229d65dcd5836ddc#the-increment-in-for-loop-post-condition-can-be-made-unchecked) **per iteration**. So it is recommended to use `unchecked` increments when overflow is not possible.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L85-L88](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L85-L88) ):

```solidity
85:         for (
86:             uint transferIndex = 0;
87:             transferIndex < Math.max(sourcesLength, targetsLength);
88:             transferIndex++
```

### [G&#x2011;12] Using assembly to check for zero can save gas


Using assembly to check for zero can save gas by allowing more direct access to the evm and reducing some of the overhead associated with high-level operations in solidity.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L185](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L185) ):

```solidity
185:         if (bytecodeSize == 0) {
```

### [G&#x2011;13] Use `assembly` to write address/contract type storage values


Using `assembly { sstore(state.slot, addr)` instead of `state = addr` can save gas.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L48](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L48) ):

```solidity
48:         token = _token;
```

### [G&#x2011;14] Use `!= 0` or `== 0` for unsigned integer comparison


For uint comparison in `require()` statements prior to solidity 0.8.13, it is cheaper to use `!= 0` or `== 0` instead of `> 0` or `<= 0` for unsigned integer comparison in.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L75](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L75), [#L75](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L75) ):

```solidity
/// @audit Replace with `!= 0`
75:             sourcesLength > 0 || targetsLength > 0,

/// @audit Replace with `!= 0`
75:             sourcesLength > 0 || targetsLength > 0,
```

### [G&#x2011;15] Avoid contract existence checks by using low level calls


Prior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L195](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L195) ):

```solidity
195:         return ERC1155(this).balanceOf(msg.sender, uint256(uint160(delegate)));
```

### [G&#x2011;16] Avoid zero transfer to save gas


In Solidity, unnecessary operations can waste gas. For example, a transfer function without a zero amount check uses gas even if called with a zero amount, since the contract state remains unchanged. Implementing a zero amount check avoids these unnecessary function calls, saving gas and improving efficiency.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [G&#x2011;17] Optimize names to save gas


`public`/`external` function names and `public` member variable names can be optimized to save gas. Below are the interfaces/abstract contracts that can be optimized so that the most frequently-called functions use the least amount of gas possible during method lookup. Method IDs that have two leading zero bytes can save 128 gas each during deployment, and renaming functions to have lower method IDs will save 22 gas per call, [per sorted position shifted](https://medium.com/joyso/solidity-how-does-function-name-affect-gas-consumption-in-smart-contract-47d270d8ac92).

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
/// @audit delegateMulti(), setUri(), token
25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [G&#x2011;18] Reduce gas usage by moving to Solidity 0.8.19 or later


Solidity version 0.8.19 introduced a number of gas optimizations, refer to the [Solidity 0.8.19 Release Announcement](https://soliditylang.org/blog/2023/02/22/solidity-0.8.19-release-announcement) for details.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L2](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2) ):

```solidity
2: pragma solidity ^0.8.2;
```

### [G&#x2011;19] Newer versions of solidity are more gas efficient


The solidity language continues to pursue more efficient gas optimization schemes. Adopting a newer version of solidity can be more gas efficient.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L2](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L2) ):

```solidity
2: pragma solidity ^0.8.2;
```

### [G&#x2011;20] Avoid updating storage when the value hasn't changed


Manipulating storage in solidity is gas-intensive. It can be optimized by avoiding unnecessary storage updates when the new value equals the existing value.
If the old value is equal to the new value, not re-storing the value will avoid a Gsreset (**2900 gas**), potentially at the expense of a Gcoldsload (**2100 gas**) or a Gwarmaccess (**100 gas**).

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L152](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L152) ):

```solidity
152:         _setURI(uri);
```

### [G&#x2011;21] The result of a function call should be cached rather than re-calling the function


The function calls in solidity are expensive. If the same result of the same function calls are to be used several times, the result should be cached to reduce the gas consumption of repeated calls.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L65](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L65) ):

```solidity
/// @audit `Math.max(sourcesLength,targetsLength)` called on lines: 80, 87
65:     function _delegateMulti(
```

### [G&#x2011;22] Use assembly to emit events


To efficiently emit events, it's possible to utilize assembly by making use of scratch space and the free memory pointer. This approach has the advantage of potentially avoiding the costs associated with memory expansion.

However, it's important to note that in order to safely optimize this process, it is preferable to cache and restore the free memory pointer.

A good example of such practice can be seen in [Solady's](https://github.com/Vectorized/solady/blob/main/src/tokens/ERC1155.sol#L167) codebase.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L136](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L136), [#L187](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L187) ):

```solidity
136:         emit DelegationProcessed(source, target, amount);

187:             emit ProxyDeployed(delegate, proxyAddress);
```

### [G&#x2011;23] Use assembly to compute hashes to save gas


If the arguments to the encode call can fit into the scratch space (two words or fewer), then it's more efficient to use assembly to generate the hash (**80 gas**):

`keccak256(abi.encodePacked(x, y))` -> `assembly {mstore(0x00, a); mstore(0x20, b); let hash := keccak256(0x00, 0x40); }`

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L211](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L211) ):

```solidity
211:                 keccak256(bytecode)
```

### [G&#x2011;24] Use `calldata` instead of `memory` for immutable arguments


Mark data types as `calldata` instead of `memory` where possible. This makes it so that the data is not automatically loaded into memory. If the data passed into the function does not need to be changed (like updating values in an array), it can be passed in as `calldata`. The one exception to this is if the argument must later be passed into another function that takes an argument that specifies `memory` storage.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
/// @audit uri
151:     function setUri(string memory uri) external onlyOwner {
```

### [G&#x2011;25] Consider activating via-ir for deploying


By using `--via-ir` or `{"viaIR": true}`, the compiler is able to use more advanced [multi-function optimizations](https://docs.soliditylang.org/en/v0.8.17/ir-breaking-changes.html#solidity-ir-based-codegen-changes), for extra gas savings.

There is 1 instance:

- [*ERC20MultiDelegate.sol*](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol)

## Disputed Issues

### [D&#x2011;01] ~~`abi.encodePacked()` should be replaced with `bytes.concat()`~~


Solidity version 0.8.4 introduces `bytes.concat()`, which can be used to replace `abi.encodePacked()` on bytes/strings. It can make the intended operation clearer, leading to less reviewer confusion.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L207-L212](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L207-L212) ):

```solidity
/// @audit abi.encodePacked() is clearer for non-bytes parameters.
207:             abi.encodePacked(
208:                 bytes1(0xff),
209:                 address(this),
210:                 uint256(0), // salt
211:                 keccak256(bytecode)
212:             )
```

### [D&#x2011;02] ~~Event names should use CamelCase~~


The instances below are already CamelCase (events are supposed to use CamelCase, not lowerCamelCase).

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L32](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L32), [#L33](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L33) ):

```solidity
32:     event ProxyDeployed(address indexed delegate, address proxyAddress);

33:     event DelegationProcessed(
```

### [D&#x2011;03] ~~Cast to `bytes` or `bytes32` for clearer semantic meaning~~


The rule is valid, but the following findings are invalid.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L202-L205](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L202-L205), [#L207-L212](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L207-L212) ):

```solidity
202:         bytes memory bytecode = abi.encodePacked(
203:             type(ERC20ProxyDelegator).creationCode, 
204:             abi.encode(_token, _delegate)
205:         );

207:             abi.encodePacked(
208:                 bytes1(0xff),
209:                 address(this),
210:                 uint256(0), // salt
211:                 keccak256(bytecode)
212:             )
```

### [D&#x2011;04] ~~Return values of `approve()` not checked~~


The following are for known contracts that will revert if they fail.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L17](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L17) ):

```solidity
17:         _token.approve(msg.sender, type(uint256).max);
```

### [D&#x2011;05] ~~Event is missing `indexed` fields~~


Index event fields makes the field more quickly accessible to [off-chain tools](https://ethereum.stackexchange.com/questions/40396/can-somebody-please-explain-the-concept-of-event-indexing) that parse events. However, note that each indexed field costs extra gas during emission, so it's not necessarily best to index the maximum allowed per event (three fields). Each event should use three indexed fields if there are three or more fields, and gas usage is not particularly of concern for the events in question. If there are fewer than three fields, all of the fields should be indexed.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L33-L37](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L33-L37) ):

```solidity
33:     event DelegationProcessed(
34:         address indexed from,
35:         address indexed to,
36:         uint256 amount
37:     );
```

### [D&#x2011;06] ~~Passing `abi.encodePacked()` with dynamic arguments to a hash can cause collisions~~


The cases below do not have multiple `bytes`/`string` arguments

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L206-L213](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L206-L213) ):

```solidity
206:         bytes32 hash = keccak256(
207:             abi.encodePacked(
208:                 bytes1(0xff),
209:                 address(this),
210:                 uint256(0), // salt
211:                 keccak256(bytecode)
212:             )
213:         );
```

### [D&#x2011;07] ~~NatSpec: Contract declarations should have `@notice` tags~~


The `@notice` is used to explain to users what the contract does. The compiler interprets `///` or `/**` comments [as this tag](https://docs.soliditylang.org/en/latest/natspec-format.html#tags) if one wasn't explicitly provided.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L15](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L15), [#L25](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L25) ):

```solidity
15: contract ERC20ProxyDelegator {

25: contract ERC20MultiDelegate is ERC1155, Ownable {
```

### [D&#x2011;08] ~~Not initializing local variables to zero saves gas~~


This is only true for state variables, and does not save gas for [local variables](https://gist.github.com/IllIllI000/e075d189c1b23dce256cd166e28f3397). The examples below are for local variables and therefore do not save gas, and are invalid.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L86](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L86) ):

```solidity
86:             uint transferIndex = 0;
```

### [D&#x2011;09] ~~safeMint should be used in place of mint~~


The following are not `ERC721.mint()` calls.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L114](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L114) ):

```solidity
114:             _mintBatch(msg.sender, targets, amounts[:targetsLength], "");
```

### [D&#x2011;10] ~~Return values of `transfer()`/`transferFrom()` not checked~~


The following are non-ERC20 transfers, or for known contracts that will revert if they fail.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [D&#x2011;11] ~~SPDX identifier should be the in the first line of a solidity file~~


There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L1](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L1) ):

```solidity
1: // SPDX-License-Identifier: MIT
```

### [D&#x2011;12] ~~Use `!= 0` or `== 0` for unsigned integer comparison~~


Only valid prior to solidity version 0.8.13, and only for require() statements, and at least one of those is not true for the examples below.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L110](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L110), [#L113](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L113) ):

```solidity
110:         if (sourcesLength > 0) {

113:         if (targetsLength > 0) {
```

### [D&#x2011;13] ~~Avoid contract existence checks by using low level calls~~


Prior to 0.8.10 the compiler inserted extra code, including EXTCODESIZE (100 gas), to check for contract existence for external function calls. In more recent solidity versions, the compiler will not insert these checks if the external call has a return value. Similar behavior can be achieved in earlier versions by using low-level calls, since low level calls never check for contract existence.

There are 6 instances:

- *ERC20MultiDelegate.sol* ( [#L17](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L17), [#L18](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L18), [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170), [#L186](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L186) ):

```solidity
/// @audit Return value not used.
17:         _token.approve(msg.sender, type(uint256).max);

/// @audit Return value not used.
18:         _token.delegate(_delegate);

/// @audit Return value not used.
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

/// @audit Return value not used.
160:         token.transferFrom(msg.sender, proxyAddress, amount);

/// @audit Return value not used.
170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);

/// @audit Return value not used.
186:             new ERC20ProxyDelegator{salt: 0}(token, delegate);
```

### [D&#x2011;14] ~~Array length is not checked before access its index~~


Accessing the elements of the array without checking or ensuring the validity of the access index in advance. It may result in an unexpected out-of-bounds error, or may result in missing elements when trying to traverse the entire array.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L57-L61](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L57-L61) ):

```solidity
57:     function delegateMulti(
58:         uint256[] calldata sources,
59:         uint256[] calldata targets,
60:         uint256[] calldata amounts
61:     ) external {
```

### [D&#x2011;15] ~~`safeTransfer` function does not check for contract existence~~


The examples below are either not token transfers, or are making high-level `transfer()`/`transferFrom()` calls (which check for contract existence), or are from a library that checks for contract existence.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L16](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L16), [#L44](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L44) ):

```solidity
16:     constructor(ERC20Votes _token, address _delegate) {

44:     constructor(
```

### [D&#x2011;16] ~~Low level calls with solidity before 0.8.14 result in an optimiser bug~~


This assembly block does not call `mstore()`, so it's not possible to hit the bug here even if there are small future changes, so this doesn't seem low severity.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L180](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L180) ):

```solidity
/// @audit `mstore` not involved
180:         assembly {
```

### [D&#x2011;17] ~~Functions calling contracts/addresses with transfer hooks should be protected by reentrancy guard~~


The rule is valid, but the following findings are invalid.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [D&#x2011;18] ~~Governance functions should be controlled by time locks~~


Governance functions (such as upgrading contracts, setting critical parameters) should be controlled using time locks to introduce a delay between a proposal and its execution. This gives users time to exit before a potentially dangerous or malicious operation is applied.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L151](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L151) ):

```solidity
151:     function setUri(string memory uri) external onlyOwner {
```

### [D&#x2011;19] ~~Assembly block creates dirty bits~~


Writing data to the free memory pointer without later updating the free memory pointer will cause there to be dirty bits at that memory location. Not updating the free memory pointer will make it [harder](https://docs.soliditylang.org/en/latest/ir-breaking-changes.html#cleanup) for the optimizer to reason about whether the memory needs to be cleaned before use, which will lead to worse optimizations. Update the free memory pointer and annotate the block (`assembly ("memory-safe") { ... }`) to avoid this issue.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L180](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L180) ):

```solidity
180:         assembly {
```

### [D&#x2011;20] ~~Calculations should be memoized rather than re-calculating them~~


The function calls in solidity are expensive. If the same result of the same function calls are to be used several times, the result should be cached to reduce the gas consumption of repeated calls.

There are 2 instances:

- *ERC20MultiDelegate.sol* ( [#L168](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L168), [#L169](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L169) ):

```solidity
/// @audit retrieveProxyContractAddress(token,from)
168:         address proxyAddressFrom = retrieveProxyContractAddress(token, from);

/// @audit retrieveProxyContractAddress(token,to)
169:         address proxyAddressTo = retrieveProxyContractAddress(token, to);
```

### [D&#x2011;21] ~~`require()` or `revert()` statements that check input arguments should be at the top of the function~~


The rule is valid, but the following findings are invalid.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L79-L82](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L79-L82) ):

```solidity
/// @audit should check before line 70
79:         require(
80:             Math.max(sourcesLength, targetsLength) == amountsLength,
81:             "Delegate: The number of amounts must be equal to the greater of the number of sources or targets"
82:         );
```

### [D&#x2011;22] ~~Some tokens may revert when zero value transfers are made~~


The following are for known contracts that will not revert on zero transfers.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [D&#x2011;23] ~~Use `SafeCast` to downcast safely~~


The rule is valid, but the following findings are invalid.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L210](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L210) ):

```solidity
/// @audit uint256(0)
210:                 uint256(0), // salt
```

### [D&#x2011;24] ~~Unsafe use of ERC20 `transfer()`/`transferFrom()`~~


Some tokens do not implement the ERC20 standard properly. For example Tether (USDT)'s `transfer()` and `transferFrom()` functions do not return booleans as the ERC20 specification requires, and instead have no return value. When these sorts of tokens are cast to IERC20/ERC20, their function signatures do not match and therefore the calls made will revert.
It is recommended to use the [`SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f347b410cf6aeeaaf5197e1fece139c793c03b2b/contracts/token/ERC20/utils/SafeERC20.sol#L19)'s `safeTransfer()` and `safeTransferFrom()` from OpenZeppelin instead.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [D&#x2011;25] ~~Use assembly to compute hashes to save gas~~


If the arguments to the encode call can fit into the scratch space (two words or fewer), then it's more efficient to use assembly to generate the hash (**80 gas**):

`keccak256(abi.encodePacked(x, y))` -> `assembly {mstore(0x00, a); mstore(0x20, b); let hash := keccak256(0x00, 0x40); }`

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L206-L213](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L206-L213) ):

```solidity
206:         bytes32 hash = keccak256(
207:             abi.encodePacked(
208:                 bytes1(0xff),
209:                 address(this),
210:                 uint256(0), // salt
211:                 keccak256(bytecode)
212:             )
213:         );
```

### [D&#x2011;26] ~~Contracts should have full test coverage~~


While 100% code coverage does not guarantee that there are no bugs, it often will catch easy-to-find bugs, and will ensure that there are fewer regressions when the code invariably has to be modified. Furthermore, in order to get full coverage, code authors will often have to re-organize their code so that it is more modular, so that each component can be tested separately, which reduces interdependencies between modules and layers, and makes for code that is easier to reason about and audit.

There is 1 instance:

- Global finding

### [D&#x2011;27] ~~Use descriptive constant instead of 0 as a parameter~~


Passing `0` or `0x0` as a function argument can sometimes result in a security issue(e.g. passing zero as the slippage parameter). A historical example is the infamous `0x0` address bug where numerous tokens were lost. This happens because `0` can be interpreted as an uninitialized `address`, leading to transfers to the `0x0` `address`, effectively burning tokens. Moreover, `0` as a denominator in division operations would cause a runtime exception. It's also often indicative of a logical error in the caller's code.

Consider using a constant variable with a descriptive name, so it's clear that the argument is intentionally being used, and for the right reasons.

There is 1 instance:

- *ERC20MultiDelegate.sol* ( [#L207-L212](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L207-L212) ):

```solidity
207:             abi.encodePacked(
208:                 bytes1(0xff),
209:                 address(this),
210:                 uint256(0), // salt
211:                 keccak256(bytecode)
212:             )
```

### [D&#x2011;28] ~~Some tokens may revert when large transfers are made~~


Tokens such as COMP or UNI will revert when an address' balance reaches [`type(uint96).max`](https://github.com/compound-finance/compound-protocol/blob/a3214f67b73310d547e00fc578e8355911c9d376/contracts/Governance/Comp.sol#L238). Ensure that the calls below can be broken up into smaller batches if necessary.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L148](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L148), [#L160](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L160), [#L170](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L170) ):

```solidity
148:         token.transferFrom(proxyAddressFrom, msg.sender, amount);

160:         token.transferFrom(msg.sender, proxyAddress, amount);

170:         token.transferFrom(proxyAddressFrom, proxyAddressTo, amount);
```

### [D&#x2011;29] ~~Contracts are vulnerable to rebasing accounting-related issues~~


Rebasing tokens are tokens that have each holder's `balanceof()` increase over time. Aave aTokens are an example of such tokens. If rebasing tokens are used, rewards accrue to the contract holding the tokens, and cannot be withdrawn by the original depositor. To address the issue, track 'shares' deposited on a pro-rata basis, and let shares be redeemed for their proportion of the current balance at the time of the withdrawal.

There are 3 instances:

- *ERC20MultiDelegate.sol* ( [#L144](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L144), [#L155-L158](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L155-L158), [#L163-L167](https://github.com/code-423n4/2023-10-ens/blob/1adbe2cce191140657b8bccffab85103953bdccb/contracts/ERC20MultiDelegate.sol#L163-L167) ):

```solidity
144:     function _reimburse(address source, uint256 amount) internal {

155:     function createProxyDelegatorAndTransfer(
156:         address target,
157:         uint256 amount
158:     ) internal {

163:     function transferBetweenDelegators(
164:         address from,
165:         address to,
166:         uint256 amount
167:     ) internal {
```
